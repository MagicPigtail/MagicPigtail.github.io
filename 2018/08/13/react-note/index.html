<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="react-note 2018-06-13 10:21:57React基础一、React介绍React是一个用于创建 可复用、可聚合的web组件的js库。主要利用JSX（JS的一种语法糖，可防止注入攻击，并提高代码可读性）语法来构建组件。 二、React工作原理由虚拟dom管理真实dom的更新。 对于每一个组件，react会在内存中构建一个相对应的dom树，当组件状态发生变化时，react都会重">
<meta property="og:type" content="article">
<meta property="og:title" content="yangz&#39;s world">
<meta property="og:url" content="http://yoursite.com/2018/08/13/react-note/index.html">
<meta property="og:site_name" content="yangz&#39;s world">
<meta property="og:description" content="react-note 2018-06-13 10:21:57React基础一、React介绍React是一个用于创建 可复用、可聚合的web组件的js库。主要利用JSX（JS的一种语法糖，可防止注入攻击，并提高代码可读性）语法来构建组件。 二、React工作原理由虚拟dom管理真实dom的更新。 对于每一个组件，react会在内存中构建一个相对应的dom树，当组件状态发生变化时，react都会重">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/08/13/react-note/media/99aa77c394429f9836c0e662b4462069.png">
<meta property="og:image" content="http://yoursite.com/2018/08/13/react-note/media/2061793c8cf261f06e5b7c5e24c9e2a8.jpg">
<meta property="og:image" content="http://yoursite.com/2018/08/13/react-note/media/50819f644034c83a15468f4fd6ad169b.png">
<meta property="og:image" content="http://yoursite.com/2018/08/13/react-note/media/c879ef4c5a00f2b4e0b129d2b5240fe6.png">
<meta property="og:image" content="http://yoursite.com/2018/08/13/react-note/media/f719fccae7b22258f97c2c3f9490f3f2.png">
<meta property="og:image" content="http://yoursite.com/2018/08/13/react-note/media/67cb0fe8859ac4de91d873c6c7b8f651.png">
<meta property="og:image" content="http://yoursite.com/2018/08/13/react-note/media/83db2cceb0a56ffcd1a3783d1e123a6c.png">
<meta property="og:updated_time" content="2018-08-13T08:14:20.499Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yangz&#39;s world">
<meta name="twitter:description" content="react-note 2018-06-13 10:21:57React基础一、React介绍React是一个用于创建 可复用、可聚合的web组件的js库。主要利用JSX（JS的一种语法糖，可防止注入攻击，并提高代码可读性）语法来构建组件。 二、React工作原理由虚拟dom管理真实dom的更新。 对于每一个组件，react会在内存中构建一个相对应的dom树，当组件状态发生变化时，react都会重">
<meta name="twitter:image" content="http://yoursite.com/2018/08/13/react-note/media/99aa77c394429f9836c0e662b4462069.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/13/react-note/"/>





  <title> | yangz's world</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yangz's world</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/react-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="神奇的小辫子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yangz's world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T15:43:30+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p>react-note</p>
<h2 id="2018-06-13-10-21-57"><a href="#2018-06-13-10-21-57" class="headerlink" title="2018-06-13 10:21:57"></a>2018-06-13 10:21:57</h2><h1 id="React基础"><a href="#React基础" class="headerlink" title="React基础"></a>React基础</h1><h1 id="一、React介绍"><a href="#一、React介绍" class="headerlink" title="一、React介绍"></a>一、React介绍</h1><p>React是一个用于创建 <strong>可复用、可聚合</strong><br>的web组件的js库。主要利用JSX（JS的一种语法糖，可防止注入攻击，并提高代码可读性）语法来构建组件。</p>
<h1 id="二、React工作原理"><a href="#二、React工作原理" class="headerlink" title="二、React工作原理"></a>二、React工作原理</h1><p>由虚拟dom管理真实dom的更新。</p>
<p>对于每一个组件，react会<br><strong>在内存中构建一个相对应的dom树，当组件状态发生变化时，react都会重新构建整个dom数据，将当前整个dom树和上一次的dom树通过diff算法进行对比，得出dom结构变化的部分，计算出最小的步骤更新真实dom，再从操作队列中批量执行DOM更新操作。</strong><br>整个过程再内存中进行，因此效率比较高。</p>
<h1 id="三、React渲染方式"><a href="#三、React渲染方式" class="headerlink" title="三、React渲染方式"></a>三、React渲染方式</h1><p>传统：</p>
<ol>
<li><p>浏览器请求页面</p>
</li>
<li><p>服务器请求数据库</p>
</li>
<li><p>将数据传给模版</p>
</li>
<li><p>模版渲染页面</p>
</li>
</ol>
<p>React：</p>
<ol>
<li><p>用户输入或从API获取数据</p>
</li>
<li><p>将数据传给顶层组件</p>
</li>
<li><p>React将每个组件渲染出来</p>
</li>
</ol>
<p>React特点：</p>
<p>1.高效：虚拟dom，通过对dom的模拟，最大限度减少与dom的交互。</p>
<p>2.灵活：可以与已有的框架或库很好的配合。</p>
<p>3.jsx：直观定义用户界面，react的核心组成部 。</p>
<p>4.组件：构建组件，使代码更容易得到复用。</p>
<p>5.单项响应数据流：变化可预计、可控制。</p>
<p>6.React实际上只实现了MVC中的V层，所以如果是大型项目想要一套完整的框架的话，基本都需要加上ReactRouter和Flux才能写大型应用。</p>
<h1 id="四、React组件化"><a href="#四、React组件化" class="headerlink" title="四、React组件化"></a>四、React组件化</h1><p>React 允许将代码封装成组件（component），然后像插入普通 HTML<br>标签一样，在网页中插入这个组件。 <strong>React.createClass</strong> 方法就用于 <strong>生成</strong><br>一个组件类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var HelloMessage = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">&lt;HelloMessage name=&quot;John&quot; \&gt;,</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;example&apos;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 HelloMessage 就是一个组件类。模板插入 <hellomessage \=""><br>时，会自动生成 HelloMessage 的一个实例（下文的”组件”都指组件类的实例）。<br><strong>所有组件类都必须有自己的 render 方法，</strong> 用于 <strong>输出</strong> 组件。</hellomessage></p>
<p>注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，<br><strong>组件类只能包含一个顶层标签</strong> ，否则也会报错。</p>
<p>组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 <hellomessage name="John"> ，就是 HelloMessage 组件加入一个 name 属性，值为 John。<br><strong>组件的属性可以在组件类的 this.props 对象上获取</strong> ，比如 name 属性就可以通过<br>this.props.name 读取。</hellomessage></p>
<p><strong>添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for<br>属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。</strong></p>
<p>React创建组件的三种方式：</p>
<p>1.函数式定义的无状态组件</p>
<p>2.es5原生方式React.createClass定义的组件</p>
<p>3.es6形式的extends React.Component定义的组件</p>
<h3 id="（1）无状态函数式组件"><a href="#（1）无状态函数式组件" class="headerlink" title="（1）无状态函数式组件"></a>（1）无状态函数式组件</h3><p>它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。</p>
<p>具体的无状态函数式组件，其官方指出：在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。</p>
<p>无状态函数式组件形式上表现为一个只带有一个render方法的组件类，通过函数形式或者ES6<br>arrow function的形式在创建，并且该组件是无state状态的。具体的创建形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function HelloComponent(props) &#123;</span><br><span class="line"></span><br><span class="line">return &lt;div\&gt;Hello &#123;props.name&#125;&lt;/div\&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;HelloComponent name=&quot;Sebastian&quot; \&gt;, mountNode)</span><br></pre></td></tr></table></figure>
<p>无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点：</p>
<h4 id="1-组件不会被实例化，整体渲染性能得到提升"><a href="#1-组件不会被实例化，整体渲染性能得到提升" class="headerlink" title="1.组件不会被实例化，整体渲染性能得到提升"></a>1.组件不会被实例化，整体渲染性能得到提升</h4><p>因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。</p>
<h4 id="2-组件不能访问this对象"><a href="#2-组件不能访问this对象" class="headerlink" title="2.组件不能访问this对象"></a>2.组件不能访问this对象</h4><p>无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件。</p>
<h4 id="3-组件无法访问生命周期的方法"><a href="#3-组件无法访问生命周期的方法" class="headerlink" title="3.组件无法访问生命周期的方法"></a>3.组件无法访问生命周期的方法</h4><p>因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。</p>
<h4 id="4-无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用"><a href="#4-无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用" class="headerlink" title="4.无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用"></a>4.无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</h4><p>无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。</p>
<h3 id="（2）React-createClass"><a href="#（2）React-createClass" class="headerlink" title="（2）React.createClass"></a>（2）React.createClass</h3><p>React.createClass是react刚开始推荐的创建组件的方式，这是ES5的原生的JavaScript来实现的React组件，其形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">var InputControlES5 = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">propTypes: &#123;//定义传入props中的属性各种类型</span><br><span class="line"></span><br><span class="line">    initialValue: React.PropTypes.string</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">defaultProps: &#123; //组件默认的props对象</span><br><span class="line"></span><br><span class="line">    initialValue: &apos;&apos;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// 设置 initial state</span><br><span class="line"></span><br><span class="line">getInitialState: function() &#123;//组件相关的状态对象</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">        text: this.props.initialValue || &apos;placeholder&apos;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleChange: function(event) &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123; //this represents react component instance</span><br><span class="line"></span><br><span class="line">        text: event.target.value</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            Type something:</span><br><span class="line"></span><br><span class="line">            &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">InputControlES6.propTypes = &#123;</span><br><span class="line"></span><br><span class="line">initialValue: React.PropTypes.string</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">InputControlES6.defaultProps = &#123;</span><br><span class="line"></span><br><span class="line">initialValue: &apos;&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与无状态组件相比，React.createClass和后面要描述的React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，React.createClass形式自身的问题暴露出来：</p>
<h4 id="1-相对于React-Component性能开销大"><a href="#1-相对于React-Component性能开销大" class="headerlink" title="1.相对于React.Component性能开销大"></a>1.相对于React.Component性能开销大</h4><p>React.createClass会自绑定函数方法（不像React.Component只绑定需要关心的函数）导致不必要的性能开销，增加代码过时的可能性。</p>
<h4 id="2-相对于React-Component可读性更弱"><a href="#2-相对于React-Component可读性更弱" class="headerlink" title="2.相对于React.Component可读性更弱"></a>2.相对于React.Component可读性更弱</h4><p>React.createClass的mixins不够自然、直观；React.Component形式非常适合高阶组件（Higher<br>Order<br>Components–HOC）,它以更直观的形式展示了比mixins更强大的功能，并且HOC（高阶组件）是纯净的JavaScript，不用担心他们会被废弃。HOC可以参考无状态组件(Stateless<br>Component) 与高阶组件。</p>
<p><strong>自绑定函数：</strong></p>
<p><strong>getInitialState</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object getInitialState()</span><br></pre></td></tr></table></figure></p>
<p>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>
<p><strong>getDefaultProps</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object getDefaultProps()</span><br></pre></td></tr></table></figure></p>
<p>在组件类创建的时候调用一次，然后返回值被缓存下来（设置默认值）。如果父组件没有指定props<br>中的某个键，则此处返回的对象中的相应属性将会合并到<br>this.props（使用in检测属性）。</p>
<p>该方法在任何实例创建之前调用，因此不能依赖于 this.props。另外，getDefaultProps()<br>返回的任何复杂对象将会在实例间共享，而不是每个实例拥有一份拷贝。</p>
<h3 id="（3）React-Component"><a href="#（3）React-Component" class="headerlink" title="（3）React.Component"></a>（3）React.Component</h3><p>React.Component是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于<br>React.createClass可以更好实现代码复用。将上面React.createClass的形式改为React.Component形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class InputControlES6 extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    // 设置 initial state</span><br><span class="line"></span><br><span class="line">    this.state = &#123;</span><br><span class="line"></span><br><span class="line">        text: props.initialValue || &apos;placeholder&apos;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // ES6 类中函数必须手动绑定</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleChange(event) &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">        text: event.target.value</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            Type something:</span><br><span class="line"></span><br><span class="line">            &lt;input onChange=&#123;this.handleChange&#125;</span><br><span class="line"></span><br><span class="line">           value=&#123;this.state.text&#125; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputControlES6.propTypes = &#123;</span><br><span class="line"></span><br><span class="line">initialValue: React.PropTypes.string</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">InputControlES6.defaultProps = &#123;</span><br><span class="line"></span><br><span class="line">initialValue: &apos;&apos;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）React-createClass与React-Component区别"><a href="#（4）React-createClass与React-Component区别" class="headerlink" title="（4）React.createClass与React.Component区别"></a>（4）React.createClass与React.Component区别</h3><h4 id="1-函数this自绑定"><a href="#1-函数this自绑定" class="headerlink" title="1. 函数this自绑定"></a>1. 函数this自绑定</h4><p>React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，任何时候使用，直接使用this.method即可，函数中的this会被正确设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const Contacts = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">handleClick() &#123;</span><br><span class="line"></span><br><span class="line">console.log(this); // React组件实例</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Contacts extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">super(props);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleClick() &#123;</span><br><span class="line"></span><br><span class="line">console.log(this); // **null**</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，React.Component有三种手动绑定方法：可以在构造函数中完成绑定，也可以在调用时使用method.bind(this)来完成绑定，还可以使用arrow<br>function来绑定。拿上例的handleClick函数来说，其绑定可以有：</p>
<p>构造函数中绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">   super(props);</span><br><span class="line"></span><br><span class="line">   this.handleClick = this.handleClick.bind(this);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>在标签内部绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;&lt;/div&gt; //使用bind来绑定</span><br></pre></td></tr></table></figure>
<p>标签内部用箭头函数绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick=&#123;()=&gt;this.handleClick()&#125;&gt;&lt;/div&gt; //使用arrow function来绑定</span><br></pre></td></tr></table></figure>
<h4 id="2-组件属性类型propTypes及其默认props属性defaultProps配置不同"><a href="#2-组件属性类型propTypes及其默认props属性defaultProps配置不同" class="headerlink" title="2.组件属性类型propTypes及其默认props属性defaultProps配置不同"></a>2.组件属性类型propTypes及其默认props属性defaultProps配置不同</h4><p>React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const TodoItem = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">propTypes: &#123; // as an object</span><br><span class="line"></span><br><span class="line">    name: React.PropTypes.string</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getDefaultProps()&#123;   // return a object</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line"></span><br><span class="line">        name: &apos;&apos;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render()&#123;</span><br><span class="line"></span><br><span class="line">    return &lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。对应上面配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class TodoItem extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">static propTypes = &#123;//类的静态属性</span><br><span class="line"></span><br><span class="line">    name: React.PropTypes.string</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static defaultProps = &#123;//类的静态属性</span><br><span class="line"></span><br><span class="line">    name: &apos;&apos;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-Mixins的支持不同"><a href="#3-Mixins的支持不同" class="headerlink" title="3.Mixins的支持不同"></a>3.Mixins的支持不同</h4><p>Mixins(混入)是面向对象编程OOP的一种实现，<br><strong>其作用是为了复用共有的代码，将共有的代码通过抽取为一个对象，然后通过Mixins进该对象来达到代码复用</strong><br>。具体可以参考React Mixin的前世今生。</p>
<p>React.createClass在创建组件时可以使用mixins属性，以数组的形式来混合类的集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var SomeMixin = &#123;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Contacts = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">mixins: [SomeMixin],</span><br><span class="line"></span><br><span class="line">handleClick() &#123;</span><br><span class="line"></span><br><span class="line">this.doSomething(); // use mixin</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是遗憾的是React.Component这种形式并不支持Mixins，至今React团队还没有给出一个该形式下的官方解决方案；但是React开发者社区提供一个全新的方式来取代Mixins,那就是HOC（Higher-Order<br>Components高阶组件）。</p>
<h3 id="（5）如何选择哪种方式创建组件"><a href="#（5）如何选择哪种方式创建组件" class="headerlink" title="（5）如何选择哪种方式创建组件"></a>（5）如何选择哪种方式创建组件</h3><p>由于React团队已经声明React.createClass最终会被React.Component的类形式所取代。但是在找到Mixins替代方案之前是不会废弃掉React.createClass形式。所以：</p>
<p>能用React.Component创建的组件的就尽量不用React.createClass形式创建组件。</p>
<p>除此之外，创建组件的形式选择还应该根据下面来决定：</p>
<p>1、只要有可能，尽量使用无状态组件创建形式。</p>
<p>2、如需要state、生命周期方法等，使用React.Component这种es6形式创建组件</p>
<h1 id="五、组件间通信"><a href="#五、组件间通信" class="headerlink" title="五、组件间通信"></a>五、组件间通信</h1><h3 id="（1）父→子"><a href="#（1）父→子" class="headerlink" title="（1）父→子"></a>（1）父→子</h3><p>React是单向的数据流动。</p>
<p>父组件向子组件传递数据，其实就是通过props属性传递的方式，父组件的数据更新，通过props数据的流动，子组件也得到更新。</p>
<h3 id="（2）子→父"><a href="#（2）子→父" class="headerlink" title="（2）子→父"></a>（2）子→父</h3><p>若想实现父同步子的数据，则需要在子数据发生改变的时候，调用执行父props传来的回调，从而达到父的同步更新。</p>
<h3 id="（3）兄弟间"><a href="#（3）兄弟间" class="headerlink" title="（3）兄弟间"></a>（3）兄弟间</h3><p>实际上是结合父/子、子/父通信，子组件更新后，调用父组件的回调，在父组件中将更新后的数据通过props传至子组件，从而实现不同组件之间数据得到同步。</p>
<h1 id="六、React属性"><a href="#六、React属性" class="headerlink" title="六、React属性"></a>六、React属性</h1><p>子节点属性：</p>
<p>this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是<br>this.props.children 属性。它表示组件的所有子节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var NotesList = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;ol&gt;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    React.Children.map(this.props.children, function (child) &#123;</span><br><span class="line"></span><br><span class="line">      return &lt;li&gt;&#123;child&#125;&lt;/li&gt;;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;/ol&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">&lt;NotesList\&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;hello&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;world&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&lt;/NotesList\&gt;,</span><br><span class="line"></span><br><span class="line">document.body</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意， this.props.children<br>的值有三种可能：如果当前组件没有子节点，它就是 undefined<br>;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array<br>。所以，处理 this.props.children 的时候要小心。</p>
<p>React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用<br>React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是<br>undefined 还是 object。</p>
<p>属性验证：</p>
<p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。</p>
<p>组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var MyTitle = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">propTypes: &#123;</span><br><span class="line"></span><br><span class="line">title: React.PropTypes.string.isRequired,</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line"> return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的Mytitle组件有一个title属性。 <strong>PropTypes 告诉 React，这个 title<br>属性是必须的，而且它的值必须是字符串。</strong> 现在，我们设置 title<br>属性的值是一个数值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = 123;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">&lt;MyTitle title=&#123;data&#125; \&gt;,</span><br><span class="line"></span><br><span class="line">document.body</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这样一来，title属性就通不过验证了。控制台会显示一行错误信息。</p>
<p>此外，getDefaultProps 方法可以用来设置组件属性的默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var MyTitle = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">getDefaultProps : function () &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">  title : &apos;Hello World&apos;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line"> return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">&lt;MyTitle \&gt;,</span><br><span class="line"></span><br><span class="line">document.body</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面代码会输出”Hello World”。</p>
<h1 id="七、获取真实DOM"><a href="#七、获取真实DOM" class="headerlink" title="七、获取真实DOM"></a>七、获取真实DOM</h1><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM<br>（virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React<br>的设计，所有的 DOM 变动，都先在虚拟 DOM<br>上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff<br>，它可以极大提高网页的性能表现。</p>
<p>但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 <strong>ref 属性</strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">handleClick: function() &#123;</span><br><span class="line"></span><br><span class="line">this.refs.myTextInput.focus();</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&apos;text&apos; ref=&apos;myTextInput&apos; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&apos;button&apos; value=&apos;Focus the text input&apos; onClick=&#123;this.handleClick&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">&lt;MyComponent \&gt;,</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;example&apos;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，组件 MyComponent<br>的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM<br>节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 <strong>ref<br>属性</strong> ，然后 <strong>this.refs.[refName] 就会返回这个真实的 DOM 节点</strong>。</p>
<p>需要注意的是，<strong>由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟<br>DOM 插入文档以后，才能使用这个属性，否则会报错。</strong>上面代码中，通过为组件指定<br>Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取<br>this.refs.[refName] 属性。</p>
<p>React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等。</p>
<h1 id="八、状态变化"><a href="#八、状态变化" class="headerlink" title="八、状态变化"></a>八、状态变化</h1><p>组件免不了要与用户互动，React<br>的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染<br>UI。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">var LikeButton = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">getInitialState: function() &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">liked: false,</span><br><span class="line"></span><br><span class="line">test1: false</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleClick: function(event) &#123;</span><br><span class="line"></span><br><span class="line">this.setState(&#123;liked: !this.state.liked&#125;);</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">var text = this.state.liked ? &apos;like&apos; : &apos;haven\&amp;\#39;t liked&apos;;</span><br><span class="line"></span><br><span class="line">var text1 = this.state.test1 ? &apos;like&apos; : &apos;haven\&amp;\#39;t liked&apos;;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;p onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line"></span><br><span class="line">    You &#123;text&#125; this. Click to toggle.</span><br><span class="line"></span><br><span class="line">            &#123;text1&#125;</span><br><span class="line"></span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">&lt;LikeButton \&gt;,</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;example&apos;)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面代码是一个 LikeButton 组件，它的 <strong>getInitialState<br>方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取</strong><br>。当用户点击组件，导致状态变化， <strong>this.setState<br>方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件</strong> 。</p>
<p>由于 this.props 和 this.state<br>都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是， <strong>this.props<br>表示那些一旦定义，就不再改变的特性，而 this.state<br>是会随着用户互动而产生变化的特性</strong> 。</p>
<h1 id="九、表单"><a href="#九、表单" class="headerlink" title="九、表单"></a>九、表单</h1><p>用户在表单填入的内容， <strong>属于用户跟组件的互动，所以不能用 this.props 读取</strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var Input = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">getInitialState: function() &#123;</span><br><span class="line"></span><br><span class="line">return &#123;value: &apos;Hello!&apos;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleChange: function(event) &#123;</span><br><span class="line"></span><br><span class="line">this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function () &#123;</span><br><span class="line"></span><br><span class="line">var value = this.state.value;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&apos;text&apos; value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;&#123;value&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Input /&gt;, document.body);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange<br>事件的回调函数，通过 event.target.value 读取用户输入的值。textarea<br>元素、select元素、radio元素都属于这种情况。</p>
<p>执行顺序：</p>
<ol>
<li><p>（1）React. createClass({})创建组件；</p>
</li>
<li><p>（2）reactDOM.render输出组件；</p>
</li>
<li><p>（3）input标签中调用value值，查询getInitialState属性给value赋值渲染页面，onChange绑定handleChange事件；</p>
</li>
<li><p>（4）事件触发修改value值，监听到之后自动调用render方法，再次渲染组件</p>
</li>
</ol>
<h1 id="十、react生命周期"><a href="#十、react生命周期" class="headerlink" title="十、react生命周期"></a>十、react生命周期</h1><p>组件的生命周期分成三个状态：</p>
<p>Mounting：已插入真实 DOM</p>
<p>Updating：正在被重新渲染</p>
<p>Unmounting：已移出真实 DOM</p>
<p>React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did<br>函数在进入状态之后调用，三种状态共计五种处理函数。</p>
<p>componentWillMount()</p>
<p>componentDidMount()</p>
<p>componentWillUpdate(object nextProps, object nextState)</p>
<p>componentDidUpdate(object prevProps, object prevState)</p>
<p>componentWillUnmount()</p>
<p>此外，React 还提供两种特殊状态的处理函数。</p>
<p>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</p>
<p>shouldComponentUpdate(object nextProps, object<br>nextState)：组件判断是否重新渲染时调用。</p>
<p><img src="media/99aa77c394429f9836c0e662b4462069.png" alt=""></p>
<p><img src="media/2061793c8cf261f06e5b7c5e24c9e2a8.jpg" alt=""></p>
<h1 id="十一、Ajax"><a href="#十一、Ajax" class="headerlink" title="十一、Ajax"></a>十一、Ajax</h1><p>组件的数据来源，通常是通过 Ajax 请求从服务器获取， <strong>可以使用 componentDidMount<br>方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">var UserGist = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">getInitialState: function() &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">  username: &apos;&apos;,</span><br><span class="line"></span><br><span class="line">  lastGistUrl: &apos;&apos;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentDidMount: function() &#123;</span><br><span class="line"></span><br><span class="line">$.get(this.props.source, function(result) &#123;</span><br><span class="line"></span><br><span class="line">  var lastGist = result[0];</span><br><span class="line"></span><br><span class="line">  if (this.isMounted()) &#123;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line"></span><br><span class="line">      username: lastGist.owner.login,</span><br><span class="line"></span><br><span class="line">      lastGistUrl: lastGist.html_url</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;.bind(this));</span><br><span class="line"></span><br><span class="line">//这里的bind(this)是为了让函数内部的函数里的this指向react对象，从而可以调用他的isMounted、setState等方法。</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    &#123;this.state.username&#125;&apos;s last gist is</span><br><span class="line"></span><br><span class="line">    &lt;a href=&#123;this.state.lastGistUrl&#125;&gt;here&lt;/a&gt;.</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line"></span><br><span class="line">&lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; \&gt;,</span><br><span class="line"></span><br><span class="line">document.body</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。React<br>本身没有任何依赖，完全可以不用jQuery，而使用其他库。</p>
<p>我们甚至可以把一个Promise对象传入组件。</p>
<h1 id="十二、Context"><a href="#十二、Context" class="headerlink" title="十二、Context"></a>十二、Context</h1><p>Context可以提供一个全局的存储，常用于跨层级组件间的传递（不需要再一级级的传递数据）。</p>
<h3 id="（1）创建单个context"><a href="#（1）创建单个context" class="headerlink" title="（1）创建单个context"></a>（1）创建单个context</h3><p>const {Provider, Consumer} = React.createContext(defaultValue);</p>
<p>创建一个 { Provider, Consumer } 对。当 React 渲染context<br>Consumer时，它将从组件树中匹配最接近的 Provider 中读取当前的 context 值。</p>
<p>defaultValue 参数仅当 Consumer(使用者) 在树中没有匹配的 Provider(提供者)<br>时使用它。这有助于在不封装它们的情况下对组件进行测试。注意：将 undefined 作为<br>Provider(提供者) 值传递不会导致 Consumer(使用者) 使用 defaultValue 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// Context lets us pass a value deep into the component tree</span><br><span class="line"></span><br><span class="line">// without explicitly threading it through every component.</span><br><span class="line"></span><br><span class="line">// Create a context for the current theme (with &quot;light&quot; as the default).</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(&apos;light&apos;);</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">// Use a Provider to pass the current theme to the tree below.</span><br><span class="line"></span><br><span class="line">// Any component can read it, no matter how deep it is.</span><br><span class="line"></span><br><span class="line">// In this example, we&apos;re passing &apos;dark&apos; as the current value.</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;ThemeContext.Provider value=&apos;dark&apos;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Toolbar /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/ThemeContext.Provider&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A component in the middle doesn&apos;t have to</span><br><span class="line"></span><br><span class="line">// pass the theme down explicitly anymore.</span><br><span class="line"></span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ThemedButton /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ThemedButton(props) &#123;</span><br><span class="line"></span><br><span class="line">// Use a Consumer to read the current theme context.</span><br><span class="line"></span><br><span class="line">// React will find the closest theme Provider above and use its value.</span><br><span class="line"></span><br><span class="line">// In this example, the current theme is &quot;dark&quot;.</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line"></span><br><span class="line">  &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125;</span><br><span class="line"></span><br><span class="line">&lt;/ThemeContext.Consumer&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）创建多个context"><a href="#（2）创建多个context" class="headerlink" title="（2）创建多个context"></a>（2）创建多个context</h3><p>为了保持 context 的快速重新渲染，React 需要使每个 context Consumer<br>成为树中的一个独立节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">// Theme context, default to light theme</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(&apos;light&apos;);</span><br><span class="line"></span><br><span class="line">// Signed-in user context</span><br><span class="line"></span><br><span class="line">const UserContext = React.createContext(&#123;</span><br><span class="line"></span><br><span class="line">name: &apos;Guest&apos;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">const &#123;signedInUser, theme&#125; = this.props;</span><br><span class="line"></span><br><span class="line">// App component that provides initial context values</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;ThemeContext.Provider value=&#123;theme&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Layout /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/UserContext.Provider&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/ThemeContext.Provider&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Layout() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Sidebar /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Content /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// A component may consume multiple contexts</span><br><span class="line"></span><br><span class="line">function Content() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line"></span><br><span class="line">  &#123;theme =&gt; (</span><br><span class="line"></span><br><span class="line">    &lt;UserContext.Consumer&gt;</span><br><span class="line"></span><br><span class="line">      &#123;user =&gt; (</span><br><span class="line"></span><br><span class="line">        &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt;</span><br><span class="line"></span><br><span class="line">      )&#125;</span><br><span class="line"></span><br><span class="line">    &lt;/UserContext.Consumer&gt;</span><br><span class="line"></span><br><span class="line">  )&#125;</span><br><span class="line"></span><br><span class="line">&lt;/ThemeContext.Consumer&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果经常同时使用两个或多个 context<br>值，您可能需要考虑创建自己的渲染属性组件，同时提供两者。</p>
<h1 id="十三、Fragments"><a href="#十三、Fragments" class="headerlink" title="十三、Fragments"></a>十三、Fragments</h1><p>用于在table里避免标签无效的标签，片段(fragments)<br>可以让你将子元素列表添加到一个分组中，并且不会在DOM 中增加额外节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Table extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;table&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tr&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Columns /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在columns里加&lt;div>标签则生产的HTML无效，所以需要用&lt;React.Fragment>包裹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Columns extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line"></span><br><span class="line">  &lt;React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">    &lt;td&gt;Hello&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">    &lt;td&gt;World&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/React.Fragment&gt;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="十四、Mixin"><a href="#十四、Mixin" class="headerlink" title="十四、Mixin"></a>十四、Mixin</h1><p>Mixin(混入)：就是将抽离出组件相同逻辑处理部分混入到组件中，实现代码的复用。（只在createClass的方式创建组件时才可以被使用）。</p>
<ol>
<li>（1）使用方法</li>
</ol>
<p>定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var DefaultNameMixin = &#123;</span><br><span class="line"></span><br><span class="line">getDefaultProps: function () &#123;</span><br><span class="line"></span><br><span class="line">    return &#123;name: &apos;Skippy&apos;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>直接声明一个json对象，内部包含复用函数（可以是react生命周期函数）。</p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var ComponentOne = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">mixins: [DefaultNameMixin],</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">return &lt;h2&gt;Hello &#123;this.props.name&#125;&lt;/h2&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>利用props传递内部的属性。</p>
<p>当包含多个mixin时可直接在数据中添加mixin的对象名：</p>
<p>mixins: [DefaultNameMixin, DefaultFoodMixin]</p>
<ol>
<li>（2）利用mixin调用生命周期函数</li>
</ol>
<p>如何你的mixin当中包含生命周期方法，你仍然可以在你的组件中使用这些方法，而且它们都会被调用：</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">/\*\* \@jsx React.DOM \*/</span><br><span class="line"></span><br><span class="line">var DefaultNameMixin = &#123;</span><br><span class="line"></span><br><span class="line">getDefaultProps: function () &#123;</span><br><span class="line"></span><br><span class="line">    return &#123;name: &apos;Skippy&apos;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var OuterComponent = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">render: function () &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;ComponentOne /&gt;</span><br><span class="line"></span><br><span class="line">            &lt;ComponentTwo /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var ComponentOne = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">mixins: [DefaultNameMixin],</span><br><span class="line"></span><br><span class="line">render: function() &#123;</span><br><span class="line"></span><br><span class="line">    return &lt;h2&gt;Hello &#123;this.props.name&#125;&lt;/h2&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var ComponentTwo = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">mixins: [DefaultNameMixin],</span><br><span class="line"></span><br><span class="line">getDefaultProps: function () &#123;</span><br><span class="line"></span><br><span class="line">    return &#123;food: &apos;Pancakes&apos;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render: function () &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h4&gt;&#123;this.props.name&#125;&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;Favorite food: &#123;this.props.food&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.renderComponent(&lt;OuterComponent \&gt;, document.body);</span><br></pre></td></tr></table></figure></p>
<p>展示了两个 default props 都会被设置点击预览</p>
<p>两个getDefaultProps方法都将被调用，所以我们可以得到默认为Skippy的name属性和默认为Pancakes的food属性。任何一个生命周期方法或属性都会被顺利地重复调用，但是下面的情况除外：</p>
<p>1.render：包含多个render方法是不行的。React 会抛出异常：</p>
<p>Uncaught Error: Invariant Violation: ReactCompositeComponentInterface:</p>
<p>You are attempting to define <code>render</code> on your component more than once.</p>
<p>This conflict may be due to a mixin.</p>
<p>2.displayName：你多次的对它进行设置是没有问题的，但是，最终的结果只以最后一次设置为准。</p>
<p>需要指出的是，mixin是可以包含在其他的mixin中的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var UselessMixin = &#123;</span><br><span class="line"></span><br><span class="line">componentDidMount: function () &#123;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;asdas&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var LolMixin = &#123;</span><br><span class="line"></span><br><span class="line">mixins: [UselessMixin]</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var PantsOpinion = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">mixins: [LolMixin],</span><br><span class="line"></span><br><span class="line">render: function () &#123;</span><br><span class="line"></span><br><span class="line">   return (&lt;p&gt;I dislike pants&lt;/p&gt;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">React.renderComponent(&lt;PantsOpinion \&gt;, document.body);</span><br></pre></td></tr></table></figure></p>
<p>程序会在控制台打印出asdas。</p>
<ol>
<li><p>（3）注意事项</p>
</li>
<li><p>设置相同的 Prop 和<br>State会抛异常，如果你尝试在不同的地方定义相同的属性时会异常。</p>
</li>
<li><p>设置相同的方法（ <strong>生命周期函数除外</strong><br>）会抛异常，在不同的mixin中定义相同的方法，或者mixin和组件中包含了相同的方法时，会抛出异常。</p>
</li>
<li><p>（4）多个生命周期方法的调用顺序</p>
</li>
</ol>
<p>如果我们的组件和mixin中都包含了相同的生命周期方法的话会怎样呢？</p>
<p><strong>我们的mixin方法首先会被调用，然后再是组件的中方法被调用。</strong></p>
<p>那当我们的组件中包含多个mixin，而这些mixin中又包含相同的生命周期方法时，调用顺序又是如何？</p>
<p><strong>它们会根据mixins中的顺序从左到右的进行调用。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">var LogOnMountMixin = &#123;</span><br><span class="line"></span><br><span class="line">componentDidMount: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;mixin mount method&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var MoreLogOnMountMixin = &#123;</span><br><span class="line"></span><br><span class="line">componentDidMount: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;another mixin mount method&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var ComponentOne = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">mixins: [MoreLogOnMountMixin, LogOnMountMixin],</span><br><span class="line"></span><br><span class="line">componentDidMount: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;component one mount method&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ComponentTwo = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">mixins: [LogOnMountMixin, MoreLogOnMountMixin],</span><br><span class="line"></span><br><span class="line">componentDidMount: function () &#123;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;component two mount method&apos;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台将输出：</p>
<p>another mixin mount method</p>
<p>mixin mount method</p>
<p>component one mount method</p>
<p>mixin mount method</p>
<p>another mixin mount method</p>
<p>component two mount method</p>
<h1 id="十五、函数详解"><a href="#十五、函数详解" class="headerlink" title="十五、函数详解"></a>十五、函数详解</h1><h3 id="（1）setState"><a href="#（1）setState" class="headerlink" title="（1）setState"></a>（1）setState</h3><p>生命周期函数中对调用setState方法对state的 <strong>同一属性</strong> 进行 <strong>多次赋值</strong><br>时只有最后一句操作能改变state中的那个属性，原因是setState实际上是 <strong>异步实现</strong><br>的，前几次的setState都不会改变属性的值，所以在最后一句操作中的<br><strong>属性值还是初始值</strong> 。但是可以用 <strong>setTimeOut、setState的回调合promise</strong><br>使setState立即执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;val:this.state.val + 1&#125;);</span><br><span class="line"></span><br><span class="line">console.log(this.state.val);</span><br><span class="line"></span><br><span class="line">this.setState(&#123;val:this.state.val + 1&#125;);</span><br><span class="line"></span><br><span class="line">console.log(this.state.val);</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">this.setState(&#123;val:this.state.val + 1&#125;);</span><br><span class="line"></span><br><span class="line">console.log(this.state.val);</span><br><span class="line"></span><br><span class="line">this.setState(&#123;val:this.state.val + 1&#125;);</span><br><span class="line"></span><br><span class="line">console.log(this.state.val);</span><br><span class="line"></span><br><span class="line">&#125;,0)</span><br><span class="line"></span><br><span class="line">**//0**</span><br><span class="line"></span><br><span class="line">**//0**</span><br><span class="line"></span><br><span class="line">**//2**</span><br><span class="line"></span><br><span class="line">**//3**</span><br><span class="line"></span><br><span class="line">this.setState((&#123;value&#125;=&gt;&#123;</span><br><span class="line"></span><br><span class="line">value:value+1</span><br><span class="line"></span><br><span class="line">&#125;),()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">console.log(this.state.value);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setStatePromise(updator) &#123;</span><br><span class="line"></span><br><span class="line">returnnewPromise( function (resolve,reject)&#123;</span><br><span class="line"></span><br><span class="line">    this.setState(updator,resolve);</span><br><span class="line"></span><br><span class="line">&#125;.bind(this))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidMount()&#123;</span><br><span class="line"></span><br><span class="line">this.setStatePromise((&#123;value&#125;) =&gt; (&#123;</span><br><span class="line"></span><br><span class="line">    value:value+1</span><br><span class="line"></span><br><span class="line">&#125;)).then(() =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    console.log(this.state.value);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多次setState函数调用产生的效果会合并。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;name: &apos;Pororo&apos;&#125;)</span><br><span class="line"></span><br><span class="line">this.setState(&#123;age: 20&#125;)</span><br></pre></td></tr></table></figure></p>
<p>实际上的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;name: &apos;Pororo&apos;，age: 20&#125;)</span><br></pre></td></tr></table></figure></p>
<p>上面两块代码的效果是一样的。如果每次调用都引发一次生命周期更新，那性能就会消耗很大了。所以，React会将多个this.setState产生的修改放进一个队列里，等差不多的时候就会引发一次生命周期更新。</p>
<h1 id="React-Router（路由库）"><a href="#React-Router（路由库）" class="headerlink" title="React-Router（路由库）"></a>React-Router（路由库）</h1><ol>
<li>、基本用法</li>
</ol>
<h3 id="（1）简单路由"><a href="#（1）简单路由" class="headerlink" title="（1）简单路由"></a>（1）简单路由</h3><p>安装命令：npm install -S react-router</p>
<p>使用时，路由器Router就是React的一个组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Router &#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">render(&lt;Router/\&gt;, document.getElementById(&apos;app&apos;));</span><br><span class="line"></span><br><span class="line">**Router组件本身只是一个容器，真正的路由要通过Route组件定义。**</span><br><span class="line"></span><br><span class="line">import &#123; Router, Route, hashHistory &#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">render((</span><br><span class="line"></span><br><span class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&apos;/&apos; component=&#123;App&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Router\&gt;</span><br><span class="line"></span><br><span class="line">), document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure></p>
<p>挂载点为父组件的{this.props.children}（不知道自己子组件时的写法）。</p>
<h3 id="（2）通过URL获取参数"><a href="#（2）通过URL获取参数" class="headerlink" title="（2）通过URL获取参数"></a>（2）通过URL获取参数</h3><p>为了从服务器获取 message 数据，我们首先需要知道它的信息。当渲染组件时，React<br>Router 会自动向 Route 组件中注入一些有用的信息，尤其是路径中动态部分的参数。</p>
<p>子组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 来自于路径 `/inbox/messages/:id`</span><br><span class="line"></span><br><span class="line">const id = this.props.params.id</span><br></pre></td></tr></table></figure></p>
<p>父组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;messages/:id&quot; component=&#123;Message&#125; \&gt;</span><br></pre></td></tr></table></figure></p>
<p>且只有当用户访问/inbox/messages/:id时才会显示Message组件。</p>
<h3 id="（3）添加默认首页"><a href="#（3）添加默认首页" class="headerlink" title="（3）添加默认首页"></a>（3）添加默认首页</h3><p>想象一下当 URL 为 / 时，我们想渲染一个在 App 中的组件。不过在此时，App 的 render<br>中的 this.props.children 还是 undefined。这种情况我们可以使用 IndexRoute<br>来设置一个默认页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &#123; IndexRoute &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">const Dashboard = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">return &lt;div&gt;Welcome to the app!&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">React.render((</span><br><span class="line"></span><br><span class="line">&lt;Router\&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&apos;/&apos; component=&#123;App&#125;&gt;</span><br><span class="line"></span><br><span class="line">  &#123;/\* 当 url 为/时渲染 Dashboard \*/&#125;</span><br><span class="line"></span><br><span class="line">  &lt;IndexRoute component=&#123;Dashboard&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=&apos;about&apos; component=&#123;About&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=&apos;inbox&apos; component=&#123;Inbox&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Route path=&apos;messages/:id&apos; component=&#123;Message&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Router\&gt;</span><br><span class="line"></span><br><span class="line">), document.body)</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th><strong>URL</strong></th>
<th><strong>组件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>App-&gt; Dashboard</td>
</tr>
<tr>
<td>/about</td>
<td>App -&gt; About</td>
</tr>
<tr>
<td>/inbox</td>
<td>App -&gt; Inbox</td>
</tr>
<tr>
<td>/inbox/messages/:id</td>
<td>App -&gt; Inbox -&gt; Message</td>
</tr>
</tbody>
</table>
<h3 id="（4）UI-从-URL-中解耦出来"><a href="#（4）UI-从-URL-中解耦出来" class="headerlink" title="（4）UI 从 URL 中解耦出来"></a>（4）UI 从 URL 中解耦出来</h3><p>如果我们可以将 /inbox 从 /inbox/messages/:id 中去除，并且还能够让 Message 嵌套在<br>App -&gt; Inbox<br>中渲染，那会非常赞。绝对路径可以让我们做到这一点。在多层嵌套路由中使用绝对路径的能力让我们对<br>URL 拥有绝对的掌控。我们无需在 URL 中添加更多的层级，从而可以使用更简洁的 URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">React.render((</span><br><span class="line"></span><br><span class="line">&lt;Router\&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&apos;/&apos; component=&#123;App&#125;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;IndexRoute component=&#123;Dashboard&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=&apos;about&apos; component=&#123;About&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=&apos;inbox&apos; component=&#123;Inbox&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &#123;/\* 使用 /messages/:id 替换 messages/:id \*/&#125;</span><br><span class="line"></span><br><span class="line">    &lt;Route path=&apos;/messages/:id&apos; component=&#123;Message&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Router\&gt;</span><br><span class="line"></span><br><span class="line">), document.body)</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th><strong>URL</strong></th>
<th><strong>组件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>/</td>
<td>App -&gt; Dashboard</td>
</tr>
<tr>
<td>/about</td>
<td>App -&gt; About</td>
</tr>
<tr>
<td>/inbox</td>
<td>App -&gt; Inbox</td>
</tr>
<tr>
<td>/messages/:id</td>
<td>App -&gt; Inbox -&gt; Message</td>
</tr>
</tbody>
</table>
<h3 id="（5）兼容旧的-URL"><a href="#（5）兼容旧的-URL" class="headerlink" title="（5）兼容旧的 URL"></a>（5）兼容旧的 URL</h3><p>等一下，我们刚刚改变了一个 URL! 这样不好。 现在任何人访问 /inbox/messages/5<br>都会看到一个错误页面。:(</p>
<p>不要担心。我们可以使用 &lt;Redirect> 使这个 URL 重新正常工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Redirect &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">React.render((</span><br><span class="line"></span><br><span class="line">&lt;Router\&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&apos;/&apos; component=&#123;App&#125;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;IndexRoute component=&#123;Dashboard&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=&apos;about&apos; component=&#123;About&#125; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Route path=&apos;inbox&apos; component=&#123;Inbox&#125;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Route path=&apos;/messages/:id&apos; component=&#123;Message&#125; /&gt;</span><br><span class="line"></span><br><span class="line">    &#123;/\* 跳转 /inbox/messages/:id 到 /messages/:id \*/&#125;</span><br><span class="line"></span><br><span class="line">    &lt;Redirect from=&apos;messages/:id&apos; to=&apos;/messages/:id&apos; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Router\&gt;</span><br><span class="line"></span><br><span class="line">), document.body)</span><br></pre></td></tr></table></figure></p>
<p>现在当有人点击 /inbox/messages/5 这个链接，他们会被自动跳转到 /messages/5。</p>
<h3 id="（6）进入和离开的Hook"><a href="#（6）进入和离开的Hook" class="headerlink" title="（6）进入和离开的Hook"></a>（6）进入和离开的Hook</h3><p>Route 可以定义 onEnter 和 onLeave 两个 hook<br>，这些hook会在页面跳转确认时触发一次。这些 hook<br>对于一些情况非常的有用，例如权限验证或者在路由跳转前将一些数据持久化保存起来。</p>
<p>在路由跳转过程中，onLeave hook<br>会在所有将离开的路由中触发，从最下层的子路由开始直到最外层父路由结束。然后onEnter<br>hook会从最外层的父路由开始直到最下层子路由结束。</p>
<p>继续我们上面的例子，如果一个用户点击链接，从 /messages/5 跳转到<br>/about，下面是这些 hook 的执行顺序：</p>
<p>/messages/:id 的 onLeave</p>
<p>/inbox 的 onLeave</p>
<p>/about 的 onEnter</p>
<h1 id="二、路由匹配原理"><a href="#二、路由匹配原理" class="headerlink" title="二、路由匹配原理"></a>二、路由匹配原理</h1><h3 id="（1）嵌套关系"><a href="#（1）嵌套关系" class="headerlink" title="（1）嵌套关系"></a>（1）嵌套关系</h3><p>React Router 使用路由嵌套的概念来让你定义 view 的嵌套集合，当一个给定的 URL<br>被调用时， <strong>整个集合中（命中的部分）都会被渲染</strong><br>。嵌套路由被描述成一种树形结构。React Router 会 <strong>深度优先遍历</strong><br>整个路由配置来寻找一个与给定的 URL 相匹配的路由。</p>
<h3 id="（2）路径语法"><a href="#（2）路径语法" class="headerlink" title="（2）路径语法"></a>（2）路径语法</h3><p>路由路径是匹配一个（或一部分）URL 的<br>一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号：</p>
<p>:paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数</p>
<p>() – 在它内部的内容被认为是可选的</p>
<p>* – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个<br>splat 参数</p>
<p><route path="/hello/:name"> // 匹配 /hello/michael 和 /hello/ryan</route></p>
<p><route path="/hello(/:name)"> // 匹配 /hello, /hello/michael 和 /hello/ryan</route></p>
<p><route path="/files/\*.\*"> // 匹配 /files/hello.jpg 和<br>/files/path/to/hello.jpg</route></p>
<p>如果一个路由使用了相对路径，那么完整的路径将由它的所有祖先节点的路径和自身指定的相对路径拼接而成。使用绝对路径可以使路由匹配行为忽略嵌套关系。</p>
<h3 id="（3）优先级"><a href="#（3）优先级" class="headerlink" title="（3）优先级"></a>（3）优先级</h3><p>最后，路由算法会根据定义的顺序自顶向下匹配路由。因此，当你拥有两个兄弟路由节点配置时，你必须确认前一个路由不会匹配后一个路由中的路径。例如，千万不要这么做：</p>
<route path="/comments" ...="" \="">

<redirect from="/comments" ...="" \="">

<h1 id="三、History"><a href="#三、History" class="headerlink" title="三、History"></a>三、History</h1><h3 id="（1）History介绍"><a href="#（1）History介绍" class="headerlink" title="（1）History介绍"></a>（1）History介绍</h3><p>history<br>是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理，拥有统一的API。具体来说里面的history分为三类:</p>
<p>老浏览器的history: 主要通过hash来实现，对应 createHashHistory</p>
<p>高版本浏览器: 通过html5里面的history，对应 createBrowserHistory</p>
<p>node环境下: 主要存储在memeory里面，对应 createMemoryHistory。</p>
<h3 id="（2）内部解析"><a href="#（2）内部解析" class="headerlink" title="（2）内部解析"></a>（2）内部解析</h3><p>三个API的大致的技术实现如下:</p>
<p>createBrowserHistory : 利用HTML5里面的history。需要服务器配置。</p>
<p>createHashHistory : 通过hash来存储在不同状态下的history信息。不需要服务器配置。</p>
<p>createMemoryHistory : 在内存中进行历史记录的存储</p>
<p>1.2.1 执行URL前进</p>
<p>createBrowserHistory : pushState、replaceState</p>
<p>createHashHistory : location.hash=*** location.replace()</p>
<p>createMemoryHistory : 在内存中进行历史记录的存储</p>
<h3 id="（3）与react-router实现路由功能"><a href="#（3）与react-router实现路由功能" class="headerlink" title="（3）与react-router实现路由功能"></a>（3）与react-router实现路由功能</h3><p>react-router在 history<br>库的基础上，实现了URL与UI的同步，分为两个层次来描述具体的实现。</p>
<p>组件层面：</p>
<p>在 react-router 中最主要的 component 是 Router RouterContext Link ， history<br>库起到了中间桥梁的作用。</p>
<p>API层面：</p>
<p>为了简单说明，只描述使用browserHistory的实现，hashHistory的实现过程是类似的，就不在说明。</p>
<p><img src="media/50819f644034c83a15468f4fd6ad169b.png" alt=""></p>
<h1 id="四、动态路由"><a href="#四、动态路由" class="headerlink" title="四、动态路由"></a>四、动态路由</h1><p>对于大型应用来说，一个首当其冲的问题就是所需加载的 JavaScript<br>的大小。程序应当只加载当前渲染页所需的<br>JavaScript。有些开发者将这种方式称之为”代码分拆” ——<br><strong>将所有的代码分拆成多个小包，在用户浏览过程中按需加载。</strong></p>
<p>对于底层细节的修改不应该需要它上面每一层级都进行修改。举个例子，为一个照片浏览页添加一个路径不应该影响到首页加载的<br>JavaScript<br>的大小。也不能因为多个团队共用一个大型的路由配置文件而造成合并时的冲突。</p>
<p>路由是个非常适于做代码分拆的地方： <strong>它的责任就是配置好每个 view。</strong></p>
<p>React Router 里的路径匹配以及组件加载都是 <strong>异步完成</strong><br>的，不仅允许你延迟加载组件，并且可以延迟加载路由配置。在首次加载包中你只需要有一个路径定义，路由会自动解析剩下的路径。</p>
<p>Route 可以定义 getChildRoutes，getIndexRoute 和 getComponents<br>这几个函数。它们都是异步执行，并且只有在需要时才被调用。我们将这种方式称之为<br>“逐渐匹配”。 React Router 会逐渐的匹配 URL 并只加载该 URL<br>对应页面所需的路径配置和组件。</p>
<h1 id="五、跳转前确认"><a href="#五、跳转前确认" class="headerlink" title="五、跳转前确认"></a>五、跳转前确认</h1><p>React Router 提供一个 routerWillLeave 生命周期钩子，这使得 React<br>组件可以拦截正在发生的跳转，或在离开 route 前提示用户。routerWillLeave<br>返回值有以下两种：</p>
<p>return false 取消此次跳转</p>
<p>return 返回提示信息，在离开 route 前提示用户进行确认。</p>
<p>你可以在 route 组件 中引入 Lifecycle mixin 来安装这个钩子。</p>
<p>import { Lifecycle } from ‘react-router’</p>
<p>const Home = React.createClass({</p>
<p>// 假设 Home 是一个 route 组件，它可能会使用</p>
<p>// Lifecycle mixin 去获得一个 routerWillLeave 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mixins: [Lifecycle],</span><br><span class="line"></span><br><span class="line">routerWillLeave(nextLocation) &#123;</span><br><span class="line"></span><br><span class="line">if (!this.state.isSaved)</span><br><span class="line"></span><br><span class="line">  return &apos;Your work is not saved! Are you sure you want to leave?&apos;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果你想在一个深层嵌套的组件中使用 routerWillLeave 钩子，只需在 route 组件<br>中引入 RouteContext mixin，这样就会把 route 放到 context 中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Lifecycle, RouteContext &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">const Home = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">// route 会被放到 Home 和它子组件及孙子组件的 context 中，</span><br><span class="line"></span><br><span class="line">// 这样在层级树中 Home 及其所有子组件都可以拿到 route。</span><br><span class="line"></span><br><span class="line">mixins: [RouteContext],</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">return &lt;NestedForm /&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const NestedForm = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">// 后代组件使用 Lifecycle mixin 获得</span><br><span class="line"></span><br><span class="line">// 一个 routerWillLeave 的方法。</span><br><span class="line"></span><br><span class="line">mixins: [Lifecycle],</span><br><span class="line"></span><br><span class="line">routerWillLeave(nextLocation) &#123;</span><br><span class="line"></span><br><span class="line">if (!this.state.isSaved)</span><br><span class="line"></span><br><span class="line">  return &apos;Your work is not saved! Are you sure you want to leave?&apos;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="六、服务端渲染"><a href="#六、服务端渲染" class="headerlink" title="六、服务端渲染"></a>六、服务端渲染</h1><p>服务端渲染与客户端渲染有些许不同，因为你需要：</p>
<p>1.发生错误时发送一个 500 的响应</p>
<p>2.需要重定向时发送一个 30x 的响应</p>
<p>3.在渲染之前获得数据 (用 router 帮你完成这点)</p>
<p>为了迎合这一需求，你要在 &lt;Router> API 下一层使用：</p>
<p>1.使用 match 在渲染之前根据 location 匹配 route</p>
<p>2.使用 RoutingContext 同步渲染 route 组件</p>
<p>它看起来像一个虚拟的 JavaScript 服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from &apos;react-dom/server&apos;</span><br><span class="line"></span><br><span class="line">import &#123; match, RoutingContext &#125; from &apos;react-router&apos;</span><br><span class="line"></span><br><span class="line">import routes from &apos;./routes&apos;</span><br><span class="line"></span><br><span class="line">serve((req, res) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">// 注意！这里的 req.url 应该是从初始请求中获得的</span><br><span class="line"></span><br><span class="line">// 完整的 URL 路径，包括查询字符串。</span><br><span class="line"></span><br><span class="line">match(&#123; routes, location: req.url &#125;, (error, redirectLocation, renderProps)</span><br><span class="line">=&gt; &#123;</span><br><span class="line"></span><br><span class="line">if (error) &#123;</span><br><span class="line"></span><br><span class="line">  res.send(500, error.message)</span><br><span class="line"></span><br><span class="line">&#125; else if (redirectLocation) &#123;</span><br><span class="line"></span><br><span class="line">  res.redirect(302, redirectLocation.pathname + redirectLocation.search)</span><br><span class="line"></span><br><span class="line">&#125; else if (renderProps) &#123;</span><br><span class="line"></span><br><span class="line">  res.send(200, renderToString(&lt;RoutingContext &#123;...renderProps&#125; /&gt;))</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">  res.send(404, &apos;Not found&apos;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="七、路由切换时生命周期"><a href="#七、路由切换时生命周期" class="headerlink" title="七、路由切换时生命周期"></a>七、路由切换时生命周期</h1><p>路由配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line"></span><br><span class="line">&lt;IndexRoute component=&#123;Home&#125;\&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;invoices/:invoiceId&quot; component=&#123;Invoice&#125;\&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;accounts/:accountId&quot; component=&#123;Account&#125;\&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Route\&gt;</span><br></pre></td></tr></table></figure></p>
<p>（1） 当用户打开应用的 ‘/‘ 页面</p>
<p>组件 生命周期</p>
<p>App componentDidMount</p>
<p>Home componentDidMount</p>
<p>Invoice N/A</p>
<p>Account N/A</p>
<p>（2） 当用户从 ‘/‘ 跳转到 ‘/invoice/123’</p>
<p>组件 生命周期</p>
<p>App componentWillReceiveProps, componentDidUpdate</p>
<p>Home componentWillUnmount</p>
<p>Invoice componentDidMount</p>
<p>Account N/A</p>
<p>1.App从router中接收到新的props（例如 children、params、location 等数据),<br>所以App触发了componentWillReceiveProps和componentDidUpdate两个生命周期方法</p>
<p>2.Home 不再被渲染，所以它将被移除</p>
<p>3.Invoice 首次被挂载</p>
<p>（3）当用户从 /invoice/123 跳转到 /invoice/789</p>
<p>组件 生命周期</p>
<p>App componentWillReceiveProps, componentDidUpdate</p>
<p>Home N/A</p>
<p>Invoice componentWillReceiveProps, componentDidUpdate</p>
<p>Account N/A</p>
<p>所有的组件之前都已经被挂载，所以只是从router更新了props。</p>
<p>（4）当从 /invoice/789 跳转到 /accounts/123</p>
<p>组件 生命周期</p>
<p>App componentWillReceiveProps, componentDidUpdate</p>
<p>Home N/A</p>
<p>Invoice componentWillUnmount</p>
<p>Account componentDidMount</p>
<p>利用生命周期函数获取数据</p>
<p>虽然还有其他通过 router 获取数据的方法， 但是最简单的方法是通过组件生命周期 Hook<br>来实现。 前面我们已经理解了当路由改变时组件生命周期的变化， 我们可以在 Invoice<br>组件里实现一个简单的数据获取功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">let Invoice = React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">getInitialState () &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">  invoice: null</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentDidMount () &#123;</span><br><span class="line"></span><br><span class="line">// 上面的步骤2，在此初始化数据</span><br><span class="line"></span><br><span class="line">this.fetchInvoice()</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentDidUpdate (prevProps) &#123;</span><br><span class="line"></span><br><span class="line">// 上面步骤3，通过参数更新数据</span><br><span class="line"></span><br><span class="line">let oldId = prevProps.params.invoiceId</span><br><span class="line"></span><br><span class="line">let newId = this.props.params.invoiceId</span><br><span class="line"></span><br><span class="line">if (newId !== oldId)</span><br><span class="line"></span><br><span class="line">  this.fetchInvoice()</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">componentWillUnmount () &#123;</span><br><span class="line"></span><br><span class="line">// 上面步骤四，在组件移除前忽略正在进行中的请求</span><br><span class="line"></span><br><span class="line">this.ignoreLastFetch = true</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">fetchInvoice () &#123;</span><br><span class="line"></span><br><span class="line">let url = `/api/invoices/$&#123;this.props.params.invoiceId&#125;`</span><br><span class="line"></span><br><span class="line">this.request = fetch(url, (err, data) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  if (!this.ignoreLastFetch)</span><br><span class="line"></span><br><span class="line">    this.setState(&#123; invoice: data.invoice &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line"></span><br><span class="line">return &lt;InvoiceView invoice=&#123;this.state.invoice&#125;/&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="Redux（数据流框架）"><a href="#Redux（数据流框架）" class="headerlink" title="Redux（数据流框架）"></a>Redux（数据流框架）</h1><p><img src="media/c879ef4c5a00f2b4e0b129d2b5240fe6.png" alt=""></p>
<ul>
<li><p>State：一个对象，保存整个应用状态</p>
</li>
<li><p>View：React 组件构成的视图层</p>
</li>
<li><p>Action：一个对象，描述事件</p>
</li>
<li><p>connect 方法：一个函数，绑定 State 到 View</p>
</li>
<li><p>dispatch 方法：一个函数，发送 Action 到 State</p>
</li>
</ul>
<h1 id="一、基本思路梳理"><a href="#一、基本思路梳理" class="headerlink" title="一、基本思路梳理"></a>一、基本思路梳理</h1><ol>
<li>（1）react、Flux和Redux之间的关系</li>
</ol>
<h4 id="1-React："><a href="#1-React：" class="headerlink" title="1.React："></a>1.React：</h4><p>React 是一个View层的框架，用来渲染视图，它主要做几件事情：</p>
<p>组件化利用props形成单向的数据流根据state的变化来更新<br>view利用虚拟DOM来提升渲染性能。前面说到React能够根据state的变化来更新view，一般来说引起state变化的动作除了来自外部（如服务器），大部分都来自于页面上的用户活动，那页面上的用户活动怎样对state产生作用呢？React中每个组件都有<br>setState 方法用于改变组件当前的 state，所以可以把更改 state<br>的逻辑写在各自的组件里，但这样做的问题在于，当项目逻辑变得越来越复杂的时候，将很难理清state跟view之间的对应关系（一个state的变化可能引起多个view的变化，一个view上面触发的事件可能引起多个state的改变）。我们需要对所有引起state变化的情况进行统一管理，于是就有了Flux。</p>
<h4 id="2-Flux："><a href="#2-Flux：" class="headerlink" title="2.Flux："></a>2.Flux：</h4><p>Flux是一种应用架构，或者说是一种思想，它跟React本身没什么关系，它可以用在React上，也可以用在别的框架上。前面说到Flux在React中主要用来统一管理引起<br>state 变化的情况。Flux维护着一个或者多个叫做Store的变量，就像 MVC<br>里面的Model，里面存放着应用用到的所有数据，当一个事件触发时，Flux对事件进行处理，对Store进行更新，当Store发生变化时，通常是由应用的根组件（也叫controller<br>view）去获取最新的store，然后更新<br>state，之后利用React单向数据流的特点一层层将新的state向下传递实现view的更新。这里的controller<br>view可以有多个也可以不是根组件，但是这样数据流维护起来就比较麻烦。</p>
<p>View： 视图层</p>
<p>Action（动作）：视图层发出的消息（比如mouseClick）</p>
<p>Dispatcher（派发器）：用来接收Actions、执行回调函数</p>
<p>Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面</p>
<p><img src="media/f719fccae7b22258f97c2c3f9490f3f2.png" alt=""></p>
<p>Flux 的最大特点，就是数据的”单向流动”。</p>
<p>1.用户访问 View；</p>
<p>2.View 发出用户的 Action；</p>
<p>3.Dispatcher 收到 Action，要求 Store 进行相应的更新；</p>
<p>4.Store 更新后，发出一个”change”事件；</p>
<p>5.View 收到”change”事件后，更新页面。</p>
<h4 id="3-Redux："><a href="#3-Redux：" class="headerlink" title="3.Redux："></a>3.Redux：</h4><p>Redux 的作用跟 Flux 是一样的，它可以看作是 Flux<br>的一种实现，但是又有点不同，具体的区别总结起来就是：</p>
<ol>
<li>Redux 只有一个 store</li>
</ol>
<p>Flux 里面会有多个 store 存储应用数据，并在 store 里面执行更新逻辑，当 store<br>变化的时候再通知 controller-view 更新自己的数据，Redux 将各个 store<br>整合成一个完整的 store，并且可以根据这个 store 推导出应用完整的 state。 <strong>同时<br>Redux 中更新的逻辑也不在 store 中执行而是放在 reducer 中。</strong></p>
<ol>
<li>没有 Dispatcher</li>
</ol>
<p>Redux 中没有 Dispatcher 的概念，它使用 reducer 来进行事件的处理，reducer<br>是一个纯函数，这个函数被表述为(previousState, action) =&gt;<br>newState，它根据应用的状态和当前的 action 推导出新的 state。Redux 中有多个<br>reducer，每个 reducer 负责维护应用整体 state 树中的某一部分，多个 reducer<br>可以通过combineReducers方法合成一个根reducer，这个根reducer负责维护完整的<br>state，当一个 action 被发出，store 会调用 dispatch 方法向某个特定的 reducer<br>传递该 action，reducer 收到 action 之后执行对应的更新逻辑然后返回一个新的<br>state，state 的更新最终会传递到根reducer处，返回一个全新的完整的<br>state，然后传递给 view。</p>
<p>Redux适用场景：多交互、多数据源。</p>
<p>组件角度：</p>
<p>1.某个组件的状态，需要共享</p>
<p>2.某个状态需要在任何地方都可以拿到</p>
<p>3.一个组件需要改变全局状态</p>
<p>4.一个组件需要改变另一个组件的状态</p>
<h1 id="二、基本概念及API"><a href="#二、基本概念及API" class="headerlink" title="二、基本概念及API"></a>二、基本概念及API</h1><p><img src="media/67cb0fe8859ac4de91d873c6c7b8f651.png" alt=""></p>
<h3 id="（1）store"><a href="#（1）store" class="headerlink" title="（1）store"></a>（1）store</h3><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
<p>Redux 提供createStore这个函数，用来生成 Store。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const store = createStore(fn);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store<br>对象。createStore方法还可以接受第二个参数，表示 State 的最初状态。</p>
<p>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store<br>生成快照。这种时点的数据集合，就叫做 State。</p>
<p>当前时刻的 State，可以通过store.getState()拿到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const store = createStore(fn);</span><br><span class="line"></span><br><span class="line">const state = store.getState();</span><br></pre></td></tr></table></figure></p>
<p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道<br>State，就知道 View 是什么样，反之亦然。</p>
<h3 id="（2）action"><a href="#（2）action" class="headerlink" title="（2）action"></a>（2）action</h3><p>Action 是把数据从应用（译者注：这里之所以不叫 view<br>是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store<br>的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将<br>action 传到 store。</p>
<p>添加新 todo 任务的 action 是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ADD_TODO = &apos;ADD_TODO&apos;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">type: ADD_TODO,</span><br><span class="line"></span><br><span class="line">text: &apos;Build my first Redux app&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的<br>type 字段来表示将要执行的动作。多数情况下，type<br>会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放<br>action。</p>
<p>要想更新 state 中的数据，你需要发起一个 action。Action 就是一个普通 JavaScript<br>对象（注意到没，这儿没有任何魔法？）用来描述发生了什么。下面是一些 action<br>的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; type: &apos;ADD_TODO&apos;, text: &apos;Go to swimming pool&apos; &#125;</span><br><span class="line"></span><br><span class="line">&#123; type: &apos;TOGGLE_TODO&apos;, index: 1 &#125;</span><br><span class="line"></span><br><span class="line">&#123; type: &apos;SET_VISIBILITY_FILTER&apos;, filter: &apos;SHOW_ALL&apos; &#125;</span><br></pre></td></tr></table></figure></p>
<p>强制使用 action<br>来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么。如果一些东西改变了，就可以知道为什么变。action<br>就像是描述发生了什么的指示器。</p>
<p>View 要发送多少种消息，就会有多少种<br>Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action<br>Creator。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const ADD_TODO = &apos;添加 TODO&apos;;</span><br><span class="line"></span><br><span class="line">function addTodo(text) &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">type: ADD_TODO,</span><br><span class="line"></span><br><span class="line">text</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const action = addTodo(&apos;Learn Redux&apos;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，addTodo函数就是一个 Action Creator。</p>
<h3 id="（3）reducer"><a href="#（3）reducer" class="headerlink" title="（3）reducer"></a>（3）reducer</h3><p>确定了 state 对象的结构，就可以开始开发 reducer。reducer<br>就是一个纯函数，接收旧的 state 和 action，返回新的 state。</p>
<p>(previousState, action) =&gt; newState</p>
<p>之所以将这样的函数称之为reducer，是因为这种函数与被传入<br>Array.prototype.reduce(reducer, ?initialValue) 里的回调函数属于相同的类型。保持<br>reducer 纯净非常重要。永远不要在 reducer 里做这些操作：</p>
<p>1.修改传入参数；</p>
<p>2.执行有副作用的操作，如 API 请求和路由跳转；</p>
<p>3.调用非纯函数，如 Date.now() 或 Math.random()。</p>
<p><strong>只要传入参数相同，返回计算得到的下一个 state<br>就一定相同。没有特殊情况、没有副作用，没有 API<br>请求、没有变量修改，单纯执行计算。（纯函数）</strong></p>
<p>实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer<br>的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将<br>Reducer 传入createStore方法。</p>
<p>最终，为了把 action 和 state 串起来，开发一些函数，这就是<br>reducer。再次地，没有任何魔法，reducer 只是一个接收 state 和 action，并返回新的<br>state 的函数。<br>对于大的应用来说，不大可能仅仅只写一个这样的函数，所以我们编写很多小函数来分别管理<br>state 的一部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function visibilityFilter(state = &apos;SHOW_ALL&apos;, action) &#123;</span><br><span class="line"></span><br><span class="line">if (action.type === &apos;SET_VISIBILITY_FILTER&apos;) &#123;</span><br><span class="line"></span><br><span class="line">return action.filter;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">return state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function todos(state = [], action) &#123;</span><br><span class="line"></span><br><span class="line">switch (action.type) &#123;</span><br><span class="line"></span><br><span class="line">case &apos;ADD_TODO&apos;:</span><br><span class="line"></span><br><span class="line">return state.concat([&#123; text: action.text, completed: false &#125;]);</span><br><span class="line"></span><br><span class="line">case &apos;TOGGLE_TODO&apos;:</span><br><span class="line"></span><br><span class="line">return state.map((todo, index) =&gt;</span><br><span class="line"></span><br><span class="line">  action.index === index ?</span><br><span class="line"></span><br><span class="line">    &#123; text: todo.text, completed: !todo.completed &#125; :</span><br><span class="line"></span><br><span class="line">    todo</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line"></span><br><span class="line">return state;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再开发一个 reducer 调用这两个 reducer，进而来管理整个应用的 state：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function todoApp(state = &#123;&#125;, action) &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">todos: todos(state.todos, action),</span><br><span class="line"></span><br><span class="line">visibilityFilter: visibilityFilter(state.visibilityFilter, action)</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）react-redux"><a href="#（4）react-redux" class="headerlink" title="（4）react-redux"></a>（4）react-redux</h3><p>一个将react与redux结合的第三方库</p>
<p>react-redux仅有2个API，Provider和connect，Provider提供的是一个 <strong>顶层容器</strong><br>的作用，实现store的上下文传递。</p>
<p>connect方法比较复杂，虽然代码只有368行，但是为redux中常用的功能实现了和react连接的建立。</p>
<h4 id="1-Provider"><a href="#1-Provider" class="headerlink" title="1.Provider"></a>1.Provider</h4><p>Provider提供的是一个顶层容器的作用，实现store的上下文传递。</p>
<p>它的原理是React组件的context属性。</p>
<p>引入方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Import &#123;Provider, connect&#125;</span><br><span class="line"></span><br><span class="line">使用方式：</span><br><span class="line"></span><br><span class="line">&lt; Provider store=&#123;store&#125; &gt;</span><br><span class="line"></span><br><span class="line">&lt;App \&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Provider\&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-connect"><a href="#2-connect" class="headerlink" title="2.connect"></a>2.connect</h4><p>connect为redux中常用的功能实现了和react连接的建立，即store和组件的props的连接。</p>
<p>connect()一共有四个参数，但我这里只说基本的两个，mapStateToProps和mapDispatchToProps。</p>
<p>mapStateToProps：简单来说，就是把状态绑定到组件的属性当中。我们定义的state对象有哪些属性，在我们组件的props都可以查阅和获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (state, ownProps) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  return &#123;tableIndex:state.tableIndex&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在props中，我们就可以拿到了我们绑定的状态。</p>
<p>它的初值就是reducer默认返回state中的值。</p>
<p>mapDispatchToProps：在redux中介绍过，用store.dispatch(action)来发出操作，那么我们同样可以把这个方法封装起来，即绑定到我们的方法中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">    changeActive:(args)=&gt;dispatch(&#123;type:&apos;changeTable&apos;,data:args&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个方法return的就是一个dispatch函数，将该方法绑定到属性上，我们同样可以在props查看和调用。</p>
<p>这样，我们只要在组件中调用该属性中的方法，就可以发出一个特定的action，触发reducer对state进行更新。这里的reducer就是之前在redux中定义的reducer。</p>
<p>这时候state如果发生更新，因为我们已经把state也绑定到props中，那么会把这些新的props重新传递下去，组件会进行更新渲染，达到我们需要的目的。</p>
<h4 id="3-容器组件-container-和展示组件-component"><a href="#3-容器组件-container-和展示组件-component" class="headerlink" title="3.容器组件(container)和展示组件(component)"></a>3.容器组件(container)和展示组件(component)</h4><p>component只关注展示层，即UI组件。</p>
<p>特征：</p>
<ul>
<li><p>只负责 UI 的呈现，不带有任何业务逻辑</p>
</li>
<li><p>没有状态（即不使用state这个变量）</p>
</li>
<li><p>所有数据都由参数（props）提供</p>
</li>
<li><p>不使用任何 Redux 的 API</p>
</li>
</ul>
<p>container是通过connect方法把redux（一般指全局store）和展示组件关联起来的东西。</p>
<p>特征：</p>
<ul>
<li><p>负责管理数据和业务逻辑，不负责 UI 的呈现</p>
</li>
<li><p>带有内部状态</p>
</li>
<li><p>使用 Redux 的 API</p>
</li>
</ul>
<h4 id="4-mapStateToProps"><a href="#4-mapStateToProps" class="headerlink" title="4.mapStateToProps()"></a>4.mapStateToProps()</h4><p>mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI<br>组件的）props对象的映射关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const mapStateToProps = (state) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表<br>UI 组件的同名参数，后面的getVisibleTodos也是一个函数，可以从state算出 todos<br>的值。</p>
<p>mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI<br>组件的参数，从而触发 UI 组件的重新渲染。</p>
<p>mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。</p>
<h4 id="5-mapDispatchToProps"><a href="#5-mapDispatchToProps" class="headerlink" title="5.mapDispatchToProps()"></a>5.mapDispatchToProps()</h4><p>mapDispatchToProps是connect函数的第二个参数，用来建立 UI<br>组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作<br>Action，传给 Store。它可以是一个函数，也可以是一个对象。</p>
<p>如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = (</span><br><span class="line"></span><br><span class="line">dispatch,</span><br><span class="line"></span><br><span class="line">ownProps</span><br><span class="line"></span><br><span class="line">) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line"></span><br><span class="line">onClick: () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  dispatch(&#123;</span><br><span class="line"></span><br><span class="line">    type: &apos;SET_VISIBILITY_FILTER&apos;,</span><br><span class="line"></span><br><span class="line">    filter: ownProps.filter</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了<br>UI 组件的参数怎样发出 Action。</p>
<p>如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI<br>组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由<br>Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const mapDispatchToProps = &#123;</span><br><span class="line"></span><br><span class="line">onClick: (filter) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">type: &apos;SET_VISIBILITY_FILTER&apos;,</span><br><span class="line"></span><br><span class="line">filter: filter</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h1><p>一般使用Redux时需要调用redux和react-redux两个库。</p>
<p>引入方法：</p>
<p>npm install redux</p>
<p>npm install react-redux</p>
<ol>
<li>创建store</li>
</ol>
<p>在index.js文件里创建一个全局store：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from&apos;redux&apos;</span><br><span class="line"></span><br><span class="line">conststore = createStore(rootReducer)</span><br></pre></td></tr></table></figure></p>
<p>这里的rootReducer是一个总的Reducer</p>
<ol>
<li><p>引入Provider，实现store的上下文传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Provider &#125; from&apos;react-redux&apos;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line"></span><br><span class="line">&lt;Providerstore=&#123;store&#125;\&gt;</span><br><span class="line"></span><br><span class="line">&lt;App/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/Provider\&gt;,</span><br><span class="line"></span><br><span class="line">document.getElementById(&apos;root&apos;)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在actions文件夹中的index.js写入action对象</p>
</li>
</ol>
<p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">letnextTodoId = 0</span><br><span class="line"></span><br><span class="line">exportconstaddTodo = text=&gt; (&#123;</span><br><span class="line"></span><br><span class="line">type:&apos;ADD_TODO&apos;,</span><br><span class="line"></span><br><span class="line">id:nextTodoId++,</span><br><span class="line"></span><br><span class="line">text</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">exportconstsetVisibilityFilter = filter=&gt; (&#123;</span><br><span class="line"></span><br><span class="line">type:&apos;SET_VISIBILITY_FILTER&apos;,</span><br><span class="line"></span><br><span class="line">filter</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">exportconsttoggleTodo = id=&gt; (&#123;</span><br><span class="line"></span><br><span class="line">type:&apos;TOGGLE_TODO&apos;,</span><br><span class="line"></span><br><span class="line">id</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">exportconstVisibilityFilters = &#123;</span><br><span class="line"></span><br><span class="line">SHOW_ALL:&apos;SHOW_ALL&apos;,</span><br><span class="line"></span><br><span class="line">SHOW_COMPLETED:&apos;SHOW_COMPLETED&apos;,</span><br><span class="line"></span><br><span class="line">SHOW_ACTIVE:&apos;SHOW_ACTIVE&apos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般以常量定义。Actions有点像枚举。</p>
<ol>
<li>在reducers文件夹中写入reducer逻辑</li>
</ol>
<p>根据业务逻辑分块，创建index.js（总入口）和其他业务逻辑reducer（js文件）</p>
<p>业务逻辑reducer接受state和action两个参数，并返回新的state（不修改原本的state），使用switch根据不同的action返回不同的state，<br><strong>reducer最好是纯函数（不改变参数，相同的输入输出的结果一定相同）</strong></p>
<p>Index.js将各个业务逻辑reducer整合在一起，然后export出去，并提供给createStore方法作为参数。</p>
<ol>
<li>设计组件</li>
</ol>
<p>组件包括components和containers</p>
<p>components注重于表现（propTypes：对属性的类型做限定）</p>
<p>containers注重于功能（react-redux的connect：将store和组件联系在一起）。</p>
<p>可以根据export的东西划分两者：</p>
<p>export组件对象：components</p>
<p>export connect：containers</p>
<h1 id="四、使用原则"><a href="#四、使用原则" class="headerlink" title="四、使用原则"></a>四、使用原则</h1><p>Redux给react的组件提供了一个全局变量store可以存储所有数据，但是并不是要把组件内的所有数据放在全局store里面，因为如果如此，组件间就会提高耦合度。</p>
<p>一般的做法是将视图层组件和数据层组件分离。视图层用内部stare，数据层用全局store。</p>
<h1 id="五、dva"><a href="#五、dva" class="headerlink" title="五、dva"></a>五、dva</h1><p>Dva首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva<br>还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。</p>
<h3 id="（1）数据流："><a href="#（1）数据流：" class="headerlink" title="（1）数据流："></a>（1）数据流：</h3><p>数据的改变发生通常是通过用户交互行为或者浏览器行为（如路由跳转等）触发的，当此类行为会改变数据的时候可以通过<br>dispatch 发起一个 action，如果是同步行为会直接通过 Reducers 改变 State<br>，如果是异步行为（副作用）会先触发 Effects 然后流向 Reducers 最终改变 State。</p>
<p><img src="media/83db2cceb0a56ffcd1a3783d1e123a6c.png" alt=""></p>
<h3 id="（2）app-dva-opts"><a href="#（2）app-dva-opts" class="headerlink" title="（2）app = dva(opts)"></a>（2）app = dva(opts)</h3><p><strong>history</strong> ：指定给路由用的 history，默认是 hashHistory</p>
<p><strong>initialState</strong> ：指定初始数据，优先级高于 model 中的 state，默认是 {}</p>
<p>如果配置history 为 browserHistory，则创建dva对象可以写成如下写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">importcreateHistoryfrom&apos;history/createHashHistory&apos;;</span><br><span class="line"></span><br><span class="line">constapp = dva(&#123;</span><br><span class="line"></span><br><span class="line">history:createHistory(),</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）model"><a href="#（3）model" class="headerlink" title="（3）model"></a>（3）model</h3><p>相较于redux，dva将reducer和action都放在了model里面，在antd-pro架构中的model需要在common/router.js里声明路由时加上模板名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;/todoList/todoList&apos;: &#123;</span><br><span class="line"></span><br><span class="line">  component:dynamicWrapper(app, [&apos;todos&apos;], () =&gt;import(&apos;../routes/New/todoList&apos;)),</span><br><span class="line"></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>Model主要有5个属性：</p>
<h4 id="1-namespace"><a href="#1-namespace" class="headerlink" title="1.namespace"></a>1.namespace</h4><p>model 的命名空间，同时也是他在全局 state<br>上的属性，只能用字符串，不支持通过”.”的方式创建多层命名空间。</p>
<h4 id="2-state"><a href="#2-state" class="headerlink" title="2.state"></a>2.state</h4><p>reducer的初始值，优先级低于传给dva()的 opts.initialState<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">constapp = dva(&#123;</span><br><span class="line"></span><br><span class="line">initialState: &#123; count:1 &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.model(&#123;</span><br><span class="line"></span><br><span class="line">namespace:&apos;count&apos;,</span><br><span class="line"></span><br><span class="line">state:0,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>此时，在 app.start() 后 state.count 为 1</p>
<h4 id="3-reducers"><a href="#3-reducers" class="headerlink" title="3. reducers"></a>3. reducers</h4><p>以 key/value 格式定义reducer，用于处理 <strong>同步操作</strong> ，唯一可以修改 state<br>的地方，由 action 触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">reducers: &#123;</span><br><span class="line"></span><br><span class="line">    &apos;delete&apos;(state, &#123;payload: id&#125;) &#123;</span><br><span class="line"></span><br><span class="line">        console.log(state)</span><br><span class="line"></span><br><span class="line">        returnstate.filter(item=&gt;item.id !== id)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &apos;add&apos;(state, &#123;payload: text&#125;)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(state)</span><br><span class="line"></span><br><span class="line">        return [</span><br><span class="line"></span><br><span class="line">            ...state,</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                id:nextTodoId++,</span><br><span class="line"></span><br><span class="line">                text:text</span><br><span class="line"></span><br><span class="line">            &#125;]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-effects"><a href="#4-effects" class="headerlink" title="4.effects"></a>4.effects</h4><p>以 key/value 格式定义 effect。用于处理 <strong>异步操作和业务逻辑</strong> ，不直接修改<br>state。由action 触发，可以触发action，可以和服务器交互，可以获取全局 state<br>的数据等等。</p>
<p>dva框架中的effects 模块的设计思想来源于 redux-saga 框架，redux-saga<br>是一个用于管理 Redux 应用异步操作的中间件（又称异步 action）。 redux-saga<br>通过创建 Sagas 将所有的异步操作逻辑收集在一个地方集中处理，可以用来代替<br>redux-thunk 中间件。</p>
<h4 id="5-subscriptions"><a href="#5-subscriptions" class="headerlink" title="5.subscriptions"></a>5.subscriptions</h4><p>以 key/value 格式定义 subscription，subscription<br>是订阅，用于订阅一个数据源，然后根据需要 dispatch 相应的 action。</p>
<p>在 app.start() 时被执行，数据源可以是当前的时间、服务器的 websocket<br>连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p>
<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h1 id="一、proptypes"><a href="#一、proptypes" class="headerlink" title="一、proptypes"></a>一、proptypes</h1><h3 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h3><p>功能：</p>
<p>对某一个组件内的props中的变量进行类型检测</p>
<p>引入方法：</p>
<ol>
<li><p>下载本地包引入</p>
</li>
<li><p>利用npm，npm install prop-types</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>无法对undefined和null的值它无法捕捉</li>
</ol>
<h3 id="（2）使用方法"><a href="#（2）使用方法" class="headerlink" title="（2）使用方法"></a>（2）使用方法</h3><h4 id="1-利用propTypes检测全部数据类型的变量"><a href="#1-利用propTypes检测全部数据类型的变量" class="headerlink" title="1. 利用propTypes检测全部数据类型的变量"></a>1. 利用propTypes检测全部数据类型的变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Son.propTypes = &#123;</span><br><span class="line"></span><br><span class="line">    number:PropTypes.number,</span><br><span class="line"></span><br><span class="line">    array:PropTypes.array,</span><br><span class="line"></span><br><span class="line">    boolean:PropTypes.bool</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>2.通过oneOfType实现多选择检测——可规定多个检测通过的数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Son.propTypes = &#123;</span><br><span class="line"></span><br><span class="line">   number:PropTypes.oneOfType(</span><br><span class="line"></span><br><span class="line">       [PropTypes.string,PropTypes.number]</span><br><span class="line"></span><br><span class="line">     )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.通过oneOf实现多选择检测——可规定多个检测通过的变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Son.propTypes = &#123;</span><br><span class="line"></span><br><span class="line">number:PropTypes.oneOf(</span><br><span class="line"></span><br><span class="line">      [12,13]</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.arrayOf,objectOf实现多重嵌套检测</p>
</li>
</ol>
<p>arrayOf接收一个参数，这个参数是规定的数组元素的数据类型。objectOf接收的参数则是属性的数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Son.propTypes = &#123;</span><br><span class="line"></span><br><span class="line"> array:PropTypes.arrayOf(PropTypes.number)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>5.通过shape方法检测目标对象不同属性的不同数据类型</li>
</ol>
<p>如果你认真思考一下的话，你会发现3.4中的objectOf有一个缺陷，就是它内部的属性的数据类型被强行规定为一种，但通常一个对象里应该是有多种不同类型的属性了，那么这时候objectOf就不符合要求了，我们应该使用shape方法，其用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PropTypes.shape(&#123;</span><br><span class="line"></span><br><span class="line">属性1：类型1，</span><br><span class="line"></span><br><span class="line">属性2：类型2，</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Son.propTypes = &#123;</span><br><span class="line"></span><br><span class="line"> object:PropTypes.shape(&#123;</span><br><span class="line"></span><br><span class="line">  name:PropTypes.string,</span><br><span class="line"></span><br><span class="line">  age:PropTypes.number</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>6.通过isRequired检测props中某个必要的属性（如果该属性不存在就报错）</li>
</ol>
<p>有时候，我们在对某个变量进行类型检测时，我们不仅要求它符合预期的类型，同时也要求它是必须写入的，这时候就要用到isRequired。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Son.propTypes = &#123;</span><br><span class="line"></span><br><span class="line">      number:PropTypes.number.isRequired</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你不想控制number的类型而仅仅是想控制它的必要性时，可以写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number: PropTypes.any.isRequired</span><br></pre></td></tr></table></figure></p>
<h1 id="开发经验"><a href="#开发经验" class="headerlink" title="开发经验"></a>开发经验</h1><h1 id="一、数据刷新机制"><a href="#一、数据刷新机制" class="headerlink" title="一、数据刷新机制"></a>一、数据刷新机制</h1><p>场景：当数据刷新频率较频繁时，且用户每次对页面操作时需要看到实时数据时。</p>
<p>处理办法：将数据绑定到组件内部state里面，因为每次销毁组件时state都会被清空，而再次生成组件时依赖的数据会有变化，即重新渲染组件。</p>
<p>场景：当数据刷新频率不频繁，且用户每次不需要看到最新的数据时。</p>
<p>处理办法：将数据绑定到全局store中，只要不关闭该标签页，store不会被清空，下次载入时依赖的数据没有改变，不会触发重新渲染。</p>
</redirect></route>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/13/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpeg"
                alt="神奇的小辫子" />
            
              <p class="site-author-name" itemprop="name">神奇的小辫子</p>
              <p class="site-description motion-element" itemprop="description">学无止境</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2018-06-13-10-21-57"><span class="nav-number">1.</span> <span class="nav-text">2018-06-13 10:21:57</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React基础"><span class="nav-number"></span> <span class="nav-text">React基础</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、React介绍"><span class="nav-number"></span> <span class="nav-text">一、React介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、React工作原理"><span class="nav-number"></span> <span class="nav-text">二、React工作原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、React渲染方式"><span class="nav-number"></span> <span class="nav-text">三、React渲染方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、React组件化"><span class="nav-number"></span> <span class="nav-text">四、React组件化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）无状态函数式组件"><span class="nav-number">0.1.</span> <span class="nav-text">（1）无状态函数式组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-组件不会被实例化，整体渲染性能得到提升"><span class="nav-number">0.1.1.</span> <span class="nav-text">1.组件不会被实例化，整体渲染性能得到提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-组件不能访问this对象"><span class="nav-number">0.1.2.</span> <span class="nav-text">2.组件不能访问this对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-组件无法访问生命周期的方法"><span class="nav-number">0.1.3.</span> <span class="nav-text">3.组件无法访问生命周期的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用"><span class="nav-number">0.1.4.</span> <span class="nav-text">4.无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）React-createClass"><span class="nav-number">0.2.</span> <span class="nav-text">（2）React.createClass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-相对于React-Component性能开销大"><span class="nav-number">0.2.1.</span> <span class="nav-text">1.相对于React.Component性能开销大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-相对于React-Component可读性更弱"><span class="nav-number">0.2.2.</span> <span class="nav-text">2.相对于React.Component可读性更弱</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）React-Component"><span class="nav-number">0.3.</span> <span class="nav-text">（3）React.Component</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（4）React-createClass与React-Component区别"><span class="nav-number">0.4.</span> <span class="nav-text">（4）React.createClass与React.Component区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-函数this自绑定"><span class="nav-number">0.4.1.</span> <span class="nav-text">1. 函数this自绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-组件属性类型propTypes及其默认props属性defaultProps配置不同"><span class="nav-number">0.4.2.</span> <span class="nav-text">2.组件属性类型propTypes及其默认props属性defaultProps配置不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Mixins的支持不同"><span class="nav-number">0.4.3.</span> <span class="nav-text">3.Mixins的支持不同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（5）如何选择哪种方式创建组件"><span class="nav-number">0.5.</span> <span class="nav-text">（5）如何选择哪种方式创建组件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、组件间通信"><span class="nav-number"></span> <span class="nav-text">五、组件间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）父→子"><span class="nav-number">0.1.</span> <span class="nav-text">（1）父→子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）子→父"><span class="nav-number">0.2.</span> <span class="nav-text">（2）子→父</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）兄弟间"><span class="nav-number">0.3.</span> <span class="nav-text">（3）兄弟间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、React属性"><span class="nav-number"></span> <span class="nav-text">六、React属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、获取真实DOM"><span class="nav-number"></span> <span class="nav-text">七、获取真实DOM</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#八、状态变化"><span class="nav-number"></span> <span class="nav-text">八、状态变化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#九、表单"><span class="nav-number"></span> <span class="nav-text">九、表单</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十、react生命周期"><span class="nav-number"></span> <span class="nav-text">十、react生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十一、Ajax"><span class="nav-number"></span> <span class="nav-text">十一、Ajax</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十二、Context"><span class="nav-number"></span> <span class="nav-text">十二、Context</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）创建单个context"><span class="nav-number">0.1.</span> <span class="nav-text">（1）创建单个context</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）创建多个context"><span class="nav-number">0.2.</span> <span class="nav-text">（2）创建多个context</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十三、Fragments"><span class="nav-number"></span> <span class="nav-text">十三、Fragments</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十四、Mixin"><span class="nav-number"></span> <span class="nav-text">十四、Mixin</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#十五、函数详解"><span class="nav-number"></span> <span class="nav-text">十五、函数详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）setState"><span class="nav-number">0.1.</span> <span class="nav-text">（1）setState</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#React-Router（路由库）"><span class="nav-number"></span> <span class="nav-text">React-Router（路由库）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）简单路由"><span class="nav-number">0.1.</span> <span class="nav-text">（1）简单路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）通过URL获取参数"><span class="nav-number">0.2.</span> <span class="nav-text">（2）通过URL获取参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）添加默认首页"><span class="nav-number">0.3.</span> <span class="nav-text">（3）添加默认首页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（4）UI-从-URL-中解耦出来"><span class="nav-number">0.4.</span> <span class="nav-text">（4）UI 从 URL 中解耦出来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（5）兼容旧的-URL"><span class="nav-number">0.5.</span> <span class="nav-text">（5）兼容旧的 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（6）进入和离开的Hook"><span class="nav-number">0.6.</span> <span class="nav-text">（6）进入和离开的Hook</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、路由匹配原理"><span class="nav-number"></span> <span class="nav-text">二、路由匹配原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）嵌套关系"><span class="nav-number">0.1.</span> <span class="nav-text">（1）嵌套关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）路径语法"><span class="nav-number">0.2.</span> <span class="nav-text">（2）路径语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）优先级"><span class="nav-number">0.3.</span> <span class="nav-text">（3）优先级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、History"><span class="nav-number"></span> <span class="nav-text">三、History</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）History介绍"><span class="nav-number">0.1.</span> <span class="nav-text">（1）History介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）内部解析"><span class="nav-number">0.2.</span> <span class="nav-text">（2）内部解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）与react-router实现路由功能"><span class="nav-number">0.3.</span> <span class="nav-text">（3）与react-router实现路由功能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、动态路由"><span class="nav-number"></span> <span class="nav-text">四、动态路由</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、跳转前确认"><span class="nav-number"></span> <span class="nav-text">五、跳转前确认</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、服务端渲染"><span class="nav-number"></span> <span class="nav-text">六、服务端渲染</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、路由切换时生命周期"><span class="nav-number"></span> <span class="nav-text">七、路由切换时生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redux（数据流框架）"><span class="nav-number"></span> <span class="nav-text">Redux（数据流框架）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、基本思路梳理"><span class="nav-number"></span> <span class="nav-text">一、基本思路梳理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-React："><span class="nav-number">0.0.1.</span> <span class="nav-text">1.React：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Flux："><span class="nav-number">0.0.2.</span> <span class="nav-text">2.Flux：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Redux："><span class="nav-number">0.0.3.</span> <span class="nav-text">3.Redux：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、基本概念及API"><span class="nav-number"></span> <span class="nav-text">二、基本概念及API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）store"><span class="nav-number">0.1.</span> <span class="nav-text">（1）store</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）action"><span class="nav-number">0.2.</span> <span class="nav-text">（2）action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）reducer"><span class="nav-number">0.3.</span> <span class="nav-text">（3）reducer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（4）react-redux"><span class="nav-number">0.4.</span> <span class="nav-text">（4）react-redux</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Provider"><span class="nav-number">0.4.1.</span> <span class="nav-text">1.Provider</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-connect"><span class="nav-number">0.4.2.</span> <span class="nav-text">2.connect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-容器组件-container-和展示组件-component"><span class="nav-number">0.4.3.</span> <span class="nav-text">3.容器组件(container)和展示组件(component)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-mapStateToProps"><span class="nav-number">0.4.4.</span> <span class="nav-text">4.mapStateToProps()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-mapDispatchToProps"><span class="nav-number">0.4.5.</span> <span class="nav-text">5.mapDispatchToProps()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、使用方法"><span class="nav-number"></span> <span class="nav-text">三、使用方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、使用原则"><span class="nav-number"></span> <span class="nav-text">四、使用原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、dva"><span class="nav-number"></span> <span class="nav-text">五、dva</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）数据流："><span class="nav-number">0.1.</span> <span class="nav-text">（1）数据流：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）app-dva-opts"><span class="nav-number">0.2.</span> <span class="nav-text">（2）app = dva(opts)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（3）model"><span class="nav-number">0.3.</span> <span class="nav-text">（3）model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-namespace"><span class="nav-number">0.3.1.</span> <span class="nav-text">1.namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-state"><span class="nav-number">0.3.2.</span> <span class="nav-text">2.state</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-reducers"><span class="nav-number">0.3.3.</span> <span class="nav-text">3. reducers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-effects"><span class="nav-number">0.3.4.</span> <span class="nav-text">4.effects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-subscriptions"><span class="nav-number">0.3.5.</span> <span class="nav-text">5.subscriptions</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三方库"><span class="nav-number"></span> <span class="nav-text">第三方库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、proptypes"><span class="nav-number"></span> <span class="nav-text">一、proptypes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#（1）介绍"><span class="nav-number">0.1.</span> <span class="nav-text">（1）介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（2）使用方法"><span class="nav-number">0.2.</span> <span class="nav-text">（2）使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-利用propTypes检测全部数据类型的变量"><span class="nav-number">0.2.1.</span> <span class="nav-text">1. 利用propTypes检测全部数据类型的变量</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开发经验"><span class="nav-number"></span> <span class="nav-text">开发经验</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、数据刷新机制"><span class="nav-number"></span> <span class="nav-text">一、数据刷新机制</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">神奇的小辫子</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
